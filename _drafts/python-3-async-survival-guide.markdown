---
layout: post
title: Python 3 async programming survival guide
#date:   2021-04-20 00:00:00 -0300
description: All you need to know to get started in async programming using modern Python 3
#img: stimulus.png
tags: [Python, async]
---

If you're a regular python developer, you probably heard of one of the new buzzwords recently added to the language: async programming (the other one being type annotations).
These new features are becoming more and more a part of modern python idioms, and sooner or later you're going to face a codebase using them. New frameworks, such as FastAPI, leverage these features to create fast and concise programs.

In this guide, we'll go over some of the fundamentals and applications of this (not so) new programming technique.

## Concurrency and paralellism

Before proceeding to the language-specific examples, it's important to cover up some fundamentals. The first concept we have to know is the difference between concurrency and parallelism.
Parallel processes occur at the same time, for example when you have a multi-core machine. It's a strategy suitable for CPU-bound processes, like mathematical simulations and machine learning, where most time is spent on heavy calculations.
On the other hand, concurrent processes are defined as tasks that finish in overlapping time. It doesn't mean they are running in the same instant though. One example would be multitasking in a single-core machine. The concurrent model usually works well when we have IO-bound processes, that is, processes that spend a lot of time idle, waiting for some data to come in or to be sent out.

There are a few ways this concurrency can be achieved. One could be using threads and letting the OS do the scheduling automatically through time slicing. Another way would be to use a technique called cooperative multitasking. In cooperative multitasking, your functions should be instrumented by adding a few placeholding keywords, async and await, for instance, to mark the locations in which your program is expected to be waiting for a long time, and therefore can have its execution paused. When the function reaches that point, it gives control back to the scheduler and so allows it to leverage this CPU spare time to run other functions. Methods and functions that behave this way are called coroutines.

The entity responsible for running the coroutines is called the Event Loop. It acts as a scheduler, determining which coroutines should be resumed next. The event loop continuously monitors the underlying OS for events that might happen, such as IO or scheduled time events, generated by a sleep call. This is implemented by having a loop constantly making a system call, like select, to monitor the file descriptions used by the coroutines. The select call informs the loop about which descriptors are ready to be written to/read from, and by association, which coroutines are ready to be resumed.

Enough theoretical stuff, let's get into python.

## The asyncio module

At the time of writing, python has a few implementations of Event Loops, but let's stick with the built-in library called asyncio for the sake of the examples. It provides a set of tools to run and manage coroutines.

Consider the snippet below:

```python
import asyncio
from datetime import datetime

async def sleep(name):
    print(f"  {datetime.now()} {name}: Starting sleep")
    await asyncio.sleep(1)
    print(f"  {datetime.now()} {name}: Ending sleep")

async def main():
    print("Runnning coroutines sequentially:")
    await sleep("A")
    await sleep("B")

    print("Running coroutines concurrently:")
    await asyncio.gather(
        sleep("C"),
        sleep("D"),
    )

asyncio.run(main())

# Should print the following
"""
Runnning coroutines sequentially:
  2021-05-14 14:55:41.708319 A: Starting sleep
  2021-05-14 14:55:42.709583 A: Ending sleep
  2021-05-14 14:55:42.709656 B: Starting sleep
  2021-05-14 14:55:43.710615 B: Ending sleep
Running coroutines concurrently:
  2021-05-14 14:55:43.710849 C: Starting sleep
  2021-05-14 14:55:43.710917 D: Starting sleep
  2021-05-14 14:55:44.712184 C: Ending sleep
  2021-05-14 14:55:44.712286 D: Ending sleep
"""
```

The code is pretty self-explanatory, but the two interesting things here are the use of the async keyword to define the coroutines, and the usage of the await keyword, which defines points in the code where the function can be paused/resumed. At the end of the script, we called asyncio.run to start the loop, passing in the main coroutine. All coroutines should be either awaited or passed to the event loop.

Rule number one of async programming is: never block the event loop! To do so, it's essential that within the coroutines, in the path from the calling function down to the operating system, there shouldn't be any blocking calls, such as sleep, synchronously read/write from files/sending HTTP requests, etc. This means that even so you're not obliged to convert all your codebase to async at once, the parts that you do should only be using libraries prepared to be run from event loops.

## ASGI: a new standard to add WebSockets support in Django

One of the great applications of async in web development is implementing WebSocket servers. As opposed to regular HTTP request/response cycles, which are synchronous and stateless. When using WebSockets, the server and the client must keep a stateful connection that can last for hours, exchanging messages once in a while, so the server needs to be able to keep lots of processes running on his end.

Having a server running hundreds or thousands of threads doesn't scale well, but, with cooperative multitasking, we have a feasible alternative. Assuming that most of the time, the processes are going to be idle, waiting for some data or user interaction, event loops seemed a really good fit to keep the multitasking overhead at bay.

The problem is: the whole application stack must be rewritten to achieve this. Web frameworks like Django were not prepared to be used this way. And even the WSGI protocol, used to exchange data between the server and the web apps, had to the rethought.
That's when the ASGI standard came about, a new protocol for integration of frameworks and the webservers supporting async. With the advent of this new interface, many new tools were created or improved to support the emerging standard, including frameworks like Django (using Channels), as well as webservers like Daphne and Uvicorn. The ASGI interface also added the capability for the servers to implement Server Pushes over both WebSockets and HTTP/2.

## What an async application stack looks like

## Conclusion
